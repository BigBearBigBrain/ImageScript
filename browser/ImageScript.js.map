{"version":3,"sources":["webpack://ImageScript/webpack/universalModuleDefinition","webpack://ImageScript/./ImageScript.js","webpack://ImageScript/./utils/buffer.js","webpack://ImageScript/./utils/crc32.js","webpack://ImageScript/./utils/png.js","webpack://ImageScript/./utils/wasm/font.js","webpack://ImageScript/./utils/wasm/gif.js","webpack://ImageScript/./utils/wasm/jpeg.js","webpack://ImageScript/./utils/wasm/svg.js","webpack://ImageScript/./utils/wasm/tiff.js","webpack://ImageScript/./utils/wasm/zlib.js","webpack://ImageScript/webpack/bootstrap","webpack://ImageScript/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","png","fontlib","svglib","jpeglib","tifflib","giflib","Image","width","height","RangeError","this","__width__","__height__","__buffer__","ArrayBuffer","__view__","DataView","__u32__","Uint32Array","bitmap","Uint8ClampedArray","Symbol","iterator","y","x","offset","getUint32","r","g","b","a","rgbaToColor","h","s","l","Math","min","max","hue2rgb","p","q","t","hslaToColor","d","color","colorToRGBA","slice","__check_boundaries__","idx","subarray","pixelColor","__set_pixel__","setUint32","isNaN","TypeError","__out_of_bounds__","fill","image","set","factor","mode","RESIZE_NEAREST_NEIGHBOR","__scale__","__apply__","__resize__","RESIZE_AUTO","Error","floor","__resize_nearest_neighbor__","constructor","ySrc","xSrc","destPos","srcPos","__crop__","tY","__fast_box__","tX","nX","nY","tC","right","xPos","end","start","bottom","copyWithin","radius","radSquared","currentY","currentX","feathering","centerX","centerY","distanceFromCenter","alphaIdx","opacity","absolute","__set_channel_value__","saturation","value","i","length","rgbaToHSLA","getRGBAAt","source","yy","y_offset","xx","x_offset","fg","bg","__alpha_blend__","fa","alpha","inv_alpha","iterateWithColors","degrees","colorAvg","divisor","rgba","map","v","ignoreBlack","ignoreWhite","bwThreshold","colorCounts","Array","key","maxColorCount","mostProminentValue","forEach","el","dominantColor","angle","resize","__rotate_180__","rad","PI","sin","cos","abs","out","out_cx","out_cy","src_cx","src_cy","w","ysin","ycos","xf","yf","__interpolate__","reverse","src","x0","y0","x1","y1","x2","y2","xq","yq","out_slice","ref","__pawn__","point0","point1","weight","src_slice","wa","Frame","from","duration","colors","entries","Object","sort","positions","e","parseFloat","values","gradient","__gradient__","position","minDef","maxDef","gradients","minPos","undefined","maxPos","minVal","maxVal","push","xRad","startColor","endColor","sr","sg","sb","sa","er","eg","eb","ea","tu32","ru32","iw","ih","xco","yco","dfc","sqrt","dis","nx","ny","cO","compression","encode","level","channels","quality","init","data","view","isView","Uint8Array","buffer","byteOffset","byteLength","ImageType","isPNG","pixels","decode","isJPEG","framebuffer","pixelType","format","pixel","isTIFF","svg","size","SVG_MODE_SCALE","SVG_MODE_WIDTH","SVG_MODE_HEIGHT","includes","TextEncoder","rasterize","font","scale","text","layout","TextLayout","Font","layoutOptions","Layout","reset","max_width","maxWidth","max_height","maxHeight","wrap_style","wrapStyle","vertical_align","verticalAlign","horizontal_align","horizontalAlign","wrap_hard_breaks","wrapHardBreaks","append","crop","lines","free","xOffset","yOffset","super","frame","GIF","frames","loopCount","indexOf","reduce","acc","encoder","Encoder","add","u8","onlyExtractFirstFrame","isGIF","decoder","Decoder","frameData","delay","options","Infinity","getType","arrays","array","table","crc","crc32","Buffer","compress","decompress","__IHDR__","__IDAT__","__IEND__","__IEND_CRC__","HEAD","channels_to_color_type","1","2","3","4","depth","tmp_offset","row_length","tmp","compressed","bpc","pixel_type","0","6","bytespp","p_offset","c_offset","chunks","palette","alphaPalette","type","pxlOffset","concat","filter","filter_1","filter_2","filter_3","filter_4","newPixels","pixelView","c","pa","pb","pc","version","wasm","registry","mem","wlen","walloc","ptr","wfree","memory","encode_utf8","globalThis","Deno","core","string","decode_utf8","TextDecoder","FinalizationRegistry","font_free","layout_free","alloc","font_new","register","unregister","char","font_has","String","prototype","charCodeAt","call","font_metrics","metrics","JSON","parse","font_metrics_buffer","font_metrics_free","font_rasterize","glyph","font_rasterize_buffer","font_rasterize_metrics","font_rasterize_free","layout_new","refs","layout_clear","layout_lines","stringify","layout_reset","has_color","layout_append","layout_rasterize","layout_rasterize_width","layout_rasterize_height","layout_rasterize_buffer","layout_rasterize_free","streaming","WebAssembly","fetch","then","arrayBuffer","instance","instantiate","streams","Map","loops","slices","encoder_new","encoder_free","delete","sum","encoder_add","limit","bptr","decoder_new","decoder_width","decoder_height","decoder_free","decoder_frame","decoder_frame_x","decoder_frame_y","decoder_frame_delay","decoder_frame_width","decoder_frame_height","decoder_frame_buffer","decoder_frame_free","env","id","get","cb","copy_and_free","decode_width","decode_height","decode_format","decode_buffer","decode_free","fit","rasterize_width","rasterize_height","rasterize_buffer","rasterize_free","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"mappings":"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","file":"ImageScript.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ImageScript\"] = factory();\n\telse\n\t\troot[\"ImageScript\"] = factory();\n})(self, function() {\nreturn ","const png = require('./utils/png');\nconst fontlib = require('./utils/wasm/font');\nconst svglib = require('./utils/wasm/svg');\nconst jpeglib = require('./utils/wasm/jpeg');\nconst tifflib = require('./utils/wasm/tiff');\nconst giflib = require('./utils/wasm/gif');\n\nconst MAGIC_NUMBERS = {\n    PNG: 0x89504e47,\n    JPEG: 0xffd8ff,\n    TIFF: 0x49492a00,\n    GIF: 0x474946\n};\n\n/**\n * Represents an image; provides utility functions\n */\nclass Image {\n    /**\n     * Creates a new image with the given dimensions\n     * @param {number} width\n     * @param {number} height\n     * @returns {Image}\n     */\n    constructor(width, height) {\n        width = ~~width;\n        height = ~~height;\n\n        if (width < 1)\n            throw new RangeError('Image has to be at least 1 pixel wide');\n        if (height < 1)\n            throw new RangeError('Image has to be at least 1 pixel high');\n\n        /** @private */\n        this.__width__ = width;\n        /** @private */\n        this.__height__ = height;\n        /** @private */\n        this.__buffer__ = new ArrayBuffer(width * height * 4);\n        /** @private */\n        this.__view__ = new DataView(this.__buffer__);\n        /** @private */\n        this.__u32__ = new Uint32Array(this.__buffer__);\n        /**\n         * The images RGBA pixel data\n         * @type {Uint8ClampedArray}\n         */\n        this.bitmap = new Uint8ClampedArray(this.__buffer__);\n    }\n\n    /**\n     * @private\n     * @returns {string}\n     */\n    toString() {\n        return `Image<${this.width}x${this.height}>`;\n    }\n\n    /**\n     * The images width\n     * @returns {number}\n     */\n    get width() {\n        return this.__width__;\n    }\n\n    /**\n     * The images height\n     * @returns {number}\n     */\n    get height() {\n        return this.__height__;\n    }\n\n    /**\n     * Yields an [x,y] array for every pixel in the image\n     * @yields {[number, number]} The coordinates of the pixel\n     * @returns {void}\n     */\n    * [Symbol.iterator]() {\n        for (let y = 1; y <= this.height; y++) {\n            for (let x = 1; x <= this.width; x++) {\n                yield [x, y];\n            }\n        }\n    }\n\n    /**\n     * Yields an [x,y,color] array for every pixel in the image\n     * @yields {[number, number, number]} The coordinates and color of the pixel\n     */\n    * iterateWithColors() {\n        let offset = 0;\n        for (let y = 1; y <= this.height; y++) {\n            for (let x = 1; x <= this.width; x++) {\n                yield [x, y, this.__view__.getUint32(offset, false)];\n                offset += 4;\n            }\n        }\n    }\n\n    /**\n     * Converts RGBA components to an RGBA value\n     * @param {number} r red (0..255)\n     * @param {number} g green (0..255)\n     * @param {number} b blue (0..255)\n     * @param {number} a alpha (0..255)\n     * @returns {number} RGBA value\n     */\n    static rgbaToColor(r, g, b, a) {\n        return (((r & 0xff) << 24) | ((g & 0xff) << 16) | ((b & 0xff) << 8) | (a & 0xff)) >>> 0;\n    }\n\n    /**\n     * Converts RGB components to an RGBA value (assuming alpha = 255)\n     * @param {number} r red (0..255)\n     * @param {number} g green (0..255)\n     * @param {number} b blue (0..255)\n     * @returns {number} RGBA value\n     */\n    static rgbToColor(r, g, b) {\n        return Image.rgbaToColor(r, g, b, 0xff);\n    }\n\n    /**\n     * Converts HSLA colors to RGBA colors\n     * @param {number} h hue (0..1)\n     * @param {number} s saturation (0..1)\n     * @param {number} l lightness (0..1)\n     * @param {number} a opacity (0..1)\n     * @returns {number} color\n     */\n    static hslaToColor(h, s, l, a) {\n        h %= 1;\n        s = Math.min(1, Math.max(0, s));\n        l = Math.min(1, Math.max(0, l));\n        a = Math.min(1, Math.max(0, a));\n\n        let r, g, b;\n\n        if (s === 0) {\n            r = g = b = l;\n        } else {\n            const hue2rgb = (p, q, t) => {\n                if (t < 0) t += 1;\n                if (t > 1) t -= 1;\n                if (t < 1 / 6) return p + (q - p) * 6 * t;\n                if (t < 1 / 2) return q;\n                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                return p;\n            };\n\n            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            const p = 2 * l - q;\n\n            r = hue2rgb(p, q, h + 1 / 3);\n            g = hue2rgb(p, q, h);\n            b = hue2rgb(p, q, h - 1 / 3);\n        }\n\n        return Image.rgbaToColor(r * 255, g * 255, b * 255, a * 255);\n    }\n\n    /**\n     * Converts HSL colors to RGBA colors (assuming an opacity of 255)\n     * @param {number} h hue (0..1)\n     * @param {number} s saturation (0..1)\n     * @param {number} l lightness (0..1)\n     * @returns {number} color\n     */\n    static hslToColor(h, s, l) {\n        return Image.hslaToColor(h, s, l, 1);\n    }\n\n    /**\n     * Converts an RGBA value to an array of HSLA values\n     * @param r {number} (0..255)\n     * @param g {number} (0..255)\n     * @param b {number} (0..255)\n     * @param a {number} (0..255)\n     * @returns {(number)[]} The HSLA values ([H, S, L, A])\n     */\n    static rgbaToHSLA(r, g, b, a) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n\n        const max = Math.max(r, g, b), min = Math.min(r, g, b);\n        let h, s, l = (max + min) / 2;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            const d = max - min;\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n\n            h /= 6;\n        }\n\n        return [h, s, l, a / 255];\n    }\n\n    /**\n     * Converts a color value to an array of RGBA values\n     * @param {number} color The color value to convert\n     * @returns {number[]} The RGBA values ([R, G, B, A])\n     */\n    static colorToRGBA(color) {\n        return [(color >> 24) & 0xff, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff];\n    }\n\n    /**\n     * Converts a color value to an array of RGB values (ignoring the colors alpha)\n     * @param {number} color The color value to convert\n     * @returns {number[]} The RGB values ([R, G, B])\n     */\n    static colorToRGB(color) {\n        return Image.colorToRGBA(color).slice(0, 3);\n    }\n\n    /**\n     * Gets the pixel color at the specified position\n     * @param {number} x\n     * @param {number} y\n     * @returns {number} The color value\n     */\n    getPixelAt(x, y) {\n        this.__check_boundaries__(x, y);\n        return this.__view__.getUint32(((~~y - 1) * this.width + (~~x - 1)) * 4, false);\n    }\n\n    /**\n     * Gets the pixel color at the specified position\n     * @param {number} x\n     * @param {number} y\n     * @returns {Uint8ClampedArray} The RGBA value\n     */\n    getRGBAAt(x, y) {\n        this.__check_boundaries__(x, y);\n        const idx = ((~~y - 1) * this.width + (~~x - 1)) * 4;\n        return this.bitmap.subarray(idx, idx + 4);\n    }\n\n    /**\n     * Sets the pixel color for the specified position\n     * @param {number} x\n     * @param {number} y\n     * @param {number} pixelColor\n     */\n    setPixelAt(x, y, pixelColor) {\n        x = ~~x;\n        y = ~~y;\n        this.__check_boundaries__(x, y);\n        this.__set_pixel__(x, y, pixelColor);\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {number} x\n     * @param {number} y\n     * @param {number} pixelColor\n     */\n    __set_pixel__(x, y, pixelColor) {\n        this.__view__.setUint32(((y - 1) * this.width + (x - 1)) * 4, pixelColor, false);\n    }\n\n    /**\n     * @private\n     * @param {number} x\n     * @param {number} y\n     */\n    __check_boundaries__(x, y) {\n        if (isNaN(x)) throw new TypeError(`Invalid pixel coordinates (x=${x})`);\n        if (isNaN(y)) throw new TypeError(`Invalid pixel coordinates (y=${y})`);\n        if (x < 1)\n            throw new RangeError(`${Image.__out_of_bounds__} (x=${x})<1`);\n        if (x > this.width)\n            throw new RangeError(`${Image.__out_of_bounds__} (x=${x})>(width=${this.width})`);\n        if (y < 1)\n            throw new RangeError(`${Image.__out_of_bounds__} (y=${y})<1`);\n        if (y > this.height)\n            throw new RangeError(`${Image.__out_of_bounds__} (y=${y})>(height=${this.height})`);\n    }\n\n    /**\n     * @private\n     */\n    static get __out_of_bounds__() {\n        return 'Tried referencing a pixel outside of the images boundaries:';\n    }\n\n    /**\n     * @callback colorFunction\n     * @param {number} x\n     * @param {number} y\n     * @returns {number} pixel color\n     */\n\n    /**\n     * Fills the image data with the supplied color\n     * @param {number|colorFunction} color\n     * @returns {Image}\n     */\n    fill(color) {\n        const type = typeof color;\n        if (type !== 'function') {\n            this.__view__.setUint32(0, color, false);\n            this.__u32__.fill(this.__u32__[0]);\n        } else {\n            let offset = 0;\n            for (let y = 1; y <= this.height; y++) {\n                for (let x = 1; x <= this.width; x++) {\n                    this.__view__.setUint32(offset, color(x, y), false);\n                    offset += 4;\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Clones the current image\n     * @returns {Image}\n     */\n    clone() {\n        const image = new Image(this.width, this.height);\n        image.bitmap.set(this.bitmap);\n        return image;\n    }\n\n    /**\n     * Use {@link https://en.wikipedia.org/wiki/Image_scaling#Nearest-neighbor_interpolation Nearest-neighbor} resizing.\n     * @returns {string}\n     */\n    static get RESIZE_NEAREST_NEIGHBOR() {\n        return 'RESIZE_NEAREST_NEIGHBOR';\n    }\n\n    /**\n     * Used for automatically preserving an images aspect ratio when resizing.\n     * @returns {number}\n     */\n    static get RESIZE_AUTO() {\n        return -1;\n    }\n\n    /**\n     * Resizes the image by the given factor\n     * @param {number} factor The factor to resize the image with\n     * @param {string} [mode=Image.RESIZE_NEAREST_NEIGHBOR] The resizing mode to use\n     * @returns {Image}\n     */\n    scale(factor, mode = Image.RESIZE_NEAREST_NEIGHBOR) {\n        const image = this.__scale__(factor, mode);\n        return this.__apply__(image);\n    }\n\n    __scale__(factor, mode = Image.RESIZE_NEAREST_NEIGHBOR) {\n        if (factor === 1) return this;\n        return this.__resize__(this.width * factor, this.height * factor, mode);\n    }\n\n    /**\n     * Resizes the image to the given dimensions.\n     * Use {@link Image.RESIZE_AUTO} as either width or height to automatically preserve the aspect ratio.\n     * @param {number} width The new width\n     * @param {number} height The new height\n     * @param {string} [mode=Image.RESIZE_NEAREST_NEIGHBOR] The resizing mode to use\n     * @returns {Image} The resized image\n     */\n    resize(width, height, mode = Image.RESIZE_NEAREST_NEIGHBOR) {\n        const image = this.__resize__(width, height, mode);\n        return this.__apply__(image);\n    }\n\n    __resize__(width, height, mode = Image.RESIZE_NEAREST_NEIGHBOR) {\n        if (width === Image.RESIZE_AUTO && height === Image.RESIZE_AUTO) throw new Error('RESIZE_AUTO can only be used for either width or height, not for both');\n        else if (width === Image.RESIZE_AUTO) width = this.width / this.height * height;\n        else if (height === Image.RESIZE_AUTO) height = this.height / this.width * width;\n\n        width = Math.floor(width);\n        height = Math.floor(height);\n        if (width < 1)\n            throw new RangeError('Image has to be at least 1 pixel wide');\n        if (height < 1)\n            throw new RangeError('Image has to be at least 1 pixel high');\n\n        let image;\n        if (mode === Image.RESIZE_NEAREST_NEIGHBOR)\n            image = this.__resize_nearest_neighbor__(width, height);\n        else throw new Error('Invalid resize mode');\n\n        return image;\n    }\n\n    /**\n     * @private\n     * @param {number} width The new width\n     * @param {number} height The new height\n     */\n    __resize_nearest_neighbor__(width, height) {\n        const image = new this.constructor(width, height);\n\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const ySrc = Math.floor((y * this.height) / height);\n                const xSrc = Math.floor((x * this.width) / width);\n\n                const destPos = (y * width + x) * 4;\n                const srcPos = (ySrc * this.width + xSrc) * 4;\n\n                image.__view__.setUint32(destPos, this.__view__.getUint32(srcPos, false), false);\n            }\n        }\n\n        return image;\n    }\n\n    /**\n     * Crops an image to the specified dimensions\n     * @param {number} x The x offset\n     * @param {number} y The y offset\n     * @param {number} width The new images width\n     * @param {number} height The new images height\n     * @returns {Image}\n     */\n    crop(x, y, width, height) {\n        if (width > this.width) width = this.width;\n        if (height > this.height) height = this.height;\n\n        return this.__apply__(this.__crop__(~~x, ~~y, ~~width, ~~height));\n    }\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @returns {Image}\n     * @private\n     */\n    __crop__(x, y, width, height) {\n        x = ~~x;\n        y = ~~y;\n\n        const image = new this.constructor(width, height);\n\n        for (let tY = 0; tY < height; tY++) {\n            const idx = (tY + y) * this.width + x;\n            image.__u32__.set(this.__u32__.subarray(idx, idx + width), tY * width);\n        }\n\n        return image;\n    }\n\n    /**\n     * Draws a box at the specified coordinates\n     * @param {number} x The x offset\n     * @param {number} y The y offset\n     * @param {number} width The box width\n     * @param {number} height The box height\n     * @param {number|colorFunction} color The color to fill the box in with\n     * @returns {Image}\n     */\n    drawBox(x, y, width, height, color) {\n        x -= 1;\n        y -= 1;\n\n        if (typeof color === 'function') {\n            for (let tY = 1; tY <= height; tY++) {\n                for (let tX = 1; tX <= width; tX++) {\n                    const nX = tX + x;\n                    const nY = tY + y;\n                    if (Math.min(nX, nY) < 1 || nX > this.width || nY > this.height)\n                        continue;\n\n                    const tC = color(tX, tY);\n                    this.__set_pixel__(nX, nY, tC);\n                }\n            }\n        } else return this.__fast_box__(x, y, width, height, color);\n\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} color\n     */\n    __fast_box__(x, y, width, height, color) {\n        if (x < 0) {\n            width += x;\n            x = 1;\n        }\n\n        if (y < 0) {\n            height += y;\n            y = 1;\n        }\n\n        const right = Math.max(Math.min(x + width, this.width), 1);\n        let xPos = right;\n        while (x <= --xPos)\n            this.__view__.setUint32(4 * (xPos + y * this.width), color);\n        const end = 4 * (right + y * this.width);\n        const start = 4 * (x + y * this.width);\n\n        let bottom = Math.max(Math.min(y + height, this.height), 1);\n        while (y < --bottom)\n            this.bitmap.copyWithin(4 * (x + bottom * this.width), start, end);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle at the specified coordinates with the specified radius\n     * @param {number} x The center x position\n     * @param {number} y The center y position\n     * @param {number} radius The circles radius\n     * @param {number|colorFunction} color\n     * @returns {Image}\n     */\n    drawCircle(x, y, radius, color) {\n        const radSquared = radius ** 2;\n        for (let currentY = Math.max(1, y - radius); currentY <= Math.min(y + radius, this.height); currentY++) {\n            for (let currentX = Math.max(1, x - radius); currentX <= Math.min(x + radius, this.width); currentX++) {\n                if ((currentX - x) ** 2 + (currentY - y) ** 2 < radSquared)\n                    this.__set_pixel__(currentX, currentY, typeof color === 'function' ? color(currentX - x + radius, currentY - y + radius) : color);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Crops the image into a circle\n     * @param {boolean} [max=false] Whether to use the larger dimension for the size\n     * @param {number} [feathering=0] How much feathering to apply to the edges\n     * @returns {Image}\n     */\n    cropCircle(max = false, feathering = 0) {\n        const rad = Math[max ? 'max' : 'min'](this.width, this.height) / 2;\n        const radSquared = rad ** 2;\n        const centerX = this.width / 2;\n        const centerY = this.height / 2;\n\n        for (const [x, y] of this) {\n            const distanceFromCenter = (x - centerX) ** 2 + (y - centerY) ** 2;\n            const alphaIdx = ((y - 1) * this.width + (x - 1)) * 4 + 3;\n            if (distanceFromCenter > radSquared)\n                this.bitmap[alphaIdx] = 0;\n            else if (feathering)\n                this.bitmap[alphaIdx] *= Math.max(0, Math.min(1, 1 - (distanceFromCenter / radSquared) * feathering ** (1 / 2)));\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets the images opacity\n     * @param {number} opacity The opacity to apply (0..1)\n     * @param {boolean} absolute Whether to scale the current opacity (false) or just set the new opacity (true)\n     * @returns {Image}\n     */\n    opacity(opacity, absolute = false) {\n        if (isNaN(opacity) || opacity < 0)\n            throw new RangeError('Invalid opacity value');\n\n        this.__set_channel_value__(opacity, absolute, 3);\n\n        return this;\n    }\n\n    /**\n     * Sets the red channels saturation\n     * @param {number} saturation The saturation to apply (0..1)\n     * @param {boolean} absolute Whether to scale the current saturation (false) or just set the new saturation (true)\n     * @returns {Image}\n     */\n    red(saturation, absolute = false) {\n        if (isNaN(saturation) || saturation < 0)\n            throw new RangeError('Invalid saturation value');\n\n        this.__set_channel_value__(saturation, absolute, 0);\n\n        return this;\n    }\n\n    /**\n     * Sets the green channels saturation\n     * @param {number} saturation The saturation to apply (0..1)\n     * @param {boolean} absolute Whether to scale the current saturation (false) or just set the new saturation (true)\n     * @returns {Image}\n     */\n    green(saturation, absolute = false) {\n        if (isNaN(saturation) || saturation < 0)\n            throw new RangeError('Invalid saturation value');\n\n        this.__set_channel_value__(saturation, absolute, 1);\n\n        return this;\n    }\n\n    /**\n     * Sets the blue channels saturation\n     * @param {number} saturation The saturation to apply (0..1)\n     * @param {boolean} absolute Whether to scale the current saturation (false) or just set the new saturation (true)\n     * @returns {Image}\n     */\n    blue(saturation, absolute = false) {\n        if (isNaN(saturation) || saturation < 0)\n            throw new RangeError('Invalid saturation value');\n\n        this.__set_channel_value__(saturation, absolute, 2);\n\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {number} value\n     * @param {boolean} absolute\n     * @param {number} offset\n     */\n    __set_channel_value__(value, absolute, offset) {\n        for (let i = offset; i < this.bitmap.length; i += 4)\n            this.bitmap[i] = value * (absolute ? 255 : this.bitmap[i]);\n    }\n\n    /**\n     * Sets the brightness of the image\n     * @param {number} value The lightness to apply (0..1)\n     * @param {boolean} absolute Whether to scale the current lightness (false) or just set the new lightness (true)\n     * @returns {Image}\n     */\n    lightness(value, absolute = false) {\n        if (isNaN(value) || value < 0)\n            throw new RangeError('Invalid lightness value');\n\n        return this.fill((x, y) => {\n            const [h, s, l, a] = Image.rgbaToHSLA(...this.getRGBAAt(x, y));\n            return Image.hslaToColor(h, s, value * (absolute ? 1 : l), a);\n        });\n    }\n\n    /**\n     * Sets the saturation of the image\n     * @param {number} value The saturation to apply (0..1)\n     * @param {boolean} absolute Whether to scale the current saturation (false) or just set the new saturation (true)\n     * @returns {Image}\n     */\n    saturation(value, absolute = false) {\n        if (isNaN(value) || value < 0)\n            throw new RangeError('Invalid saturation value');\n\n        return this.fill((x, y) => {\n            const [h, s, l, a] = Image.rgbaToHSLA(...this.getRGBAAt(x, y));\n            return Image.hslaToColor(h, value * (absolute ? 1 : s), l, a);\n        });\n    }\n\n    /**\n     * Composites (overlays) the source onto this image at the specified coordinates\n     * @param {Image} source The image to place\n     * @param {number} [x=0] The x position to place the image at\n     * @param {number} [y=0] The y position to place the image at\n     * @returns {Image}\n     */\n    composite(source, x = 0, y = 0) {\n        x = ~~x;\n        y = ~~y;\n\n        for (let yy = 0; yy < source.height; yy++) {\n            let y_offset = y + yy;\n            if (y_offset < 0) continue;\n            if (y_offset >= this.height) break;\n\n            for (let xx = 0; xx < source.width; xx++) {\n                let x_offset = x + xx;\n                if (x_offset < 0) continue;\n                if (x_offset >= this.width) break;\n\n                const offset = 4 * (x_offset + y_offset * this.width);\n                const fg = source.__view__.getUint32(4 * (xx + yy * source.width), false);\n                const bg = this.__view__.getUint32(offset, false);\n\n                if ((fg & 0xff) === 0xff) this.__view__.setUint32(offset, fg, false);\n                else if ((fg & 0xff) === 0x00) this.__view__.setUint32(offset, bg, false);\n                else this.__view__.setUint32(offset, Image.__alpha_blend__(fg, bg), false);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * @private\n     * @param {number} fg\n     * @param {number} bg\n     * @returns {number}\n     */\n    static __alpha_blend__(fg, bg) {\n        const fa = fg & 0xff;\n        const alpha = fa + 1;\n        const inv_alpha = 256 - fa;\n        const r = (alpha * (fg >>> 24) + inv_alpha * (bg >>> 24)) >> 8;\n        const b = (alpha * (fg >> 8 & 0xff) + inv_alpha * (bg >> 8 & 0xff)) >> 8;\n        const g = (alpha * (fg >> 16 & 0xff) + inv_alpha * (bg >> 16 & 0xff)) >> 8;\n        return (((r & 0xff) << 24) | ((g & 0xff) << 16) | ((b & 0xff) << 8) | (Math.max(fa, bg & 0xff) & 0xff));\n    }\n\n    /**\n     * Inverts the images colors\n     * @returns {Image}\n     */\n    invert() {\n        for (const [x, y, color] of this.iterateWithColors())\n            this.__set_pixel__(x, y, ((0xffffffff - color) & 0xffffff00) | (color & 0xff));\n\n        return this;\n    }\n\n    /**\n     * Inverts the images value (lightness)\n     * @returns {Image}\n     */\n    invertValue() {\n        for (const [x, y, color] of this.iterateWithColors()) {\n            const [h, s, l, a] = Image.rgbaToHSLA(...Image.colorToRGBA(color));\n            this.__set_pixel__(x, y, Image.hslaToColor(h, s, 1 - l, a));\n        }\n\n        return this;\n    }\n\n    /**\n     * Inverts the images saturation\n     * @returns {Image}\n     */\n    invertSaturation() {\n        for (const [x, y, color] of this.iterateWithColors()) {\n            const [h, s, l, a] = Image.rgbaToHSLA(...Image.colorToRGBA(color));\n            this.__set_pixel__(x, y, Image.hslaToColor(h, 1 - s, l, a));\n        }\n\n        return this;\n    }\n\n    /**\n     * Inverts the images hue\n     * @returns {Image}\n     */\n    invertHue() {\n        for (const [x, y, color] of this.iterateWithColors()) {\n            const [h, s, l, a] = Image.rgbaToHSLA(...Image.colorToRGBA(color));\n            this.__set_pixel__(x, y, Image.hslaToColor(1 - h, s, l, a));\n        }\n\n        return this;\n    }\n\n    /**\n     * Shifts the images hue\n     * @param {number} degrees How many degrees to shift the hue by\n     */\n    hueShift(degrees) {\n        for (const [x, y, color] of this.iterateWithColors()) {\n            const [h, s, l, a] = Image.rgbaToHSLA(...Image.colorToRGBA(color));\n            this.__set_pixel__(x, y, Image.hslaToColor(h + degrees / 360, s, l, a));\n        }\n\n        return this;\n    }\n\n    /**\n     * Gets the average color of the image\n     * @returns {number}\n     */\n    averageColor() {\n        let colorAvg = [0, 0, 0];\n        let divisor = 0;\n        for (let idx = 0; idx < this.bitmap.length; idx += 4) {\n            const rgba = this.bitmap.subarray(idx, idx + 4);\n            for (let i = 0; i < 3; i++)\n                colorAvg[i] += rgba[i];\n            divisor += rgba[3] / 255;\n        }\n\n        return Image.rgbaToColor(...colorAvg.map(v => v / divisor), 0xff);\n    }\n\n    /**\n     * Gets the images dominant color\n     * @param {boolean} [ignoreBlack=true] Whether to ignore dark colors below the threshold\n     * @param {boolean} [ignoreWhite=true] Whether to ignore light colors above the threshold\n     * @param {number} [bwThreshold=0xf] The black/white threshold (0-64)\n     * @return {number} The images dominant color\n     */\n    dominantColor(ignoreBlack = true, ignoreWhite = true, bwThreshold = 0xf) {\n        const colorCounts = new Array(0x3ffff);\n        for (let i = 0; i < this.bitmap.length; i += 4) {\n            const color = this.__view__.getUint32(i, false);\n            const [h, s, l] = Image.rgbaToHSLA(...Image.colorToRGBA(color)).map(v => (~~(v * 0x3f)));\n            if (ignoreBlack && l < bwThreshold) continue;\n            if (ignoreWhite && l > 0x3f - bwThreshold) continue;\n            const key = h << 12 | s << 6 | l;\n            colorCounts[key] = (colorCounts[key] || 0) + 1;\n        }\n\n        let maxColorCount = -1;\n        let mostProminentValue = 0;\n        colorCounts.forEach((el, i) => {\n            if (el < maxColorCount) return;\n            maxColorCount = el;\n            mostProminentValue = i;\n        });\n\n        if (mostProminentValue === -1)\n            return this.dominantColor(ignoreBlack, ignoreWhite, bwThreshold - 1);\n\n        const h = (mostProminentValue >>> 12) & 0x3f;\n        const s = (mostProminentValue >>> 6) & 0x3f;\n        const l = mostProminentValue & 0x3f;\n\n        return Image.hslaToColor(h / 0x3f, s / 0x3f, l / 0x3f, 1);\n    }\n\n    /**\n     * Rotates the image the given amount of degrees\n     * @param {number} angle The angle to rotate the image for (in degrees)\n     * @param {boolean} resize Whether to resize the image so it fits all pixels or just ignore outlying pixels\n     */\n    rotate(angle, resize = true) {\n        if (angle % 360 === 0) return this;\n        if (angle % 180 === 0) return this.__rotate_180__();\n\n        const rad = Math.PI * (angle / 180);\n\n        const sin = Math.sin(rad);\n        const cos = Math.cos(rad);\n\n        const width = resize\n            ? Math.abs(this.width * sin) + Math.abs(this.height * cos)\n            : this.width;\n        const height = resize\n            ? Math.abs(this.width * cos) + Math.abs(this.height * sin)\n            : this.height;\n\n        const out = new Image(width, height);\n\n        const out_cx = width / 2 - .5;\n        const out_cy = height / 2 - .5;\n        const src_cx = this.width / 2 - .5;\n        const src_cy = this.height / 2 - .5;\n\n        let h = 0;\n        do {\n            let w = 0;\n            const ysin = src_cx - sin * (h - out_cy);\n            const ycos = src_cy + cos * (h - out_cy);\n\n            do {\n                const xf = ysin + cos * (w - out_cx);\n                const yf = ycos + sin * (w - out_cx);\n                Image.__interpolate__(this, out, w, h, xf, yf);\n            } while (w++ < width);\n        } while (h++ < height);\n\n        return this.__apply__(out);\n    }\n\n    /**\n     * @returns {Image}\n     * @private\n     */\n    __rotate_180__() {\n        let offset = 0;\n        this.bitmap.reverse();\n        while (offset < this.bitmap.length) this.bitmap.subarray(offset, offset += 4).reverse();\n\n        return this;\n    }\n\n    /**\n     * @param {Image} src\n     * @param {Image} out\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @private\n     */\n    static __interpolate__(src, out, x0, y0, x1, y1) {\n        const x2 = ~~x1;\n        const y2 = ~~y1;\n        const xq = x1 - x2;\n        const yq = y1 - y2;\n        const out_slice = out.bitmap.subarray(4 * (x0 + y0 * out.width), -4);\n\n        const ref = {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 0,\n        };\n\n        Image.__pawn__(x2, y2, (1 - xq) * (1 - yq), ref, src);\n        Image.__pawn__(1 + x2, y2, xq * (1 - yq), ref, src);\n        Image.__pawn__(x2, 1 + y2, (1 - xq) * yq, ref, src);\n        Image.__pawn__(1 + x2, 1 + y2, xq * yq, ref, src);\n\n        out_slice[3] = ref.a;\n        out_slice[0] = ref.r / ref.a;\n        out_slice[1] = ref.g / ref.a;\n        out_slice[2] = ref.b / ref.a;\n    }\n\n    /** @private */\n    static __pawn__(point0, point1, weight, ref, src) {\n        if (\n            point0 > 0\n            && point1 > 0\n            && point0 < src.width\n            && point1 < src.height\n        ) {\n            const offset = 4 * (point0 + point1 * src.width);\n            const src_slice = src.bitmap.subarray(offset, offset + 4);\n\n            const wa = weight * src_slice[3];\n\n            ref.a += wa;\n            ref.r += wa * src_slice[0];\n            ref.g += wa * src_slice[1];\n            ref.b += wa * src_slice[2];\n        }\n    }\n\n    /**\n     * @private\n     * @param {Image|Frame} image\n     * @returns {Image|Frame}\n     */\n    __apply__(image) {\n        this.__width__ = image.__width__;\n        this.__height__ = image.__height__;\n        this.__view__ = image.__view__;\n        this.__u32__ = image.__u32__;\n        this.bitmap = image.bitmap;\n\n        if (image instanceof Frame)\n            return Frame.from(this, image.duration);\n\n        return this;\n    }\n\n    /**\n     * Creates a multi-point gradient generator\n     * @param {Object<number, number>} colors The gradient points to use (e.g. `{0: 0xff0000ff, 1: 0x00ff00ff}`)\n     * @return {(function(number): number)} The gradient generator. The function argument is the position in the gradient (0..1).\n     */\n    static gradient(colors) {\n        const entries = Object.entries(colors).sort((a, b) => a[0] - b[0]);\n        const positions = entries.map(e => parseFloat(e[0]));\n        const values = entries.map(e => e[1]);\n\n        if (positions.length === 0) throw new RangeError('Invalid gradient point count');\n        else if (positions.length === 1) {\n            return () => values[0];\n        } else if (positions.length === 2) {\n            const gradient = this.__gradient__(values[0], values[1]);\n            return position => {\n                if (position <= positions[0]) return values[0];\n                if (position >= positions[1]) return values[1];\n                return gradient((position - positions[0]) / (positions[1] - positions[0]));\n            };\n        }\n\n        const minDef = Math.min(...positions);\n        const maxDef = Math.max(...positions);\n        let gradients = [];\n\n        for (let i = 0; i < positions.length; i++) {\n            let minPos = positions[i - 1];\n            if (minPos === undefined) continue;\n\n            let maxPos = positions[i];\n\n            let minVal = values[i - 1];\n            if (minVal === undefined) minVal = values[i];\n\n            const maxVal = values[i];\n            const gradient = this.__gradient__(minVal, maxVal);\n\n            gradients.push({min: minPos, max: maxPos, gradient});\n        }\n\n        return position => {\n            if (position <= minDef) return gradients[0].gradient(0);\n            if (position >= maxDef) return gradients[gradients.length - 1].gradient(1);\n\n            for (const gradient of gradients)\n                if (position >= gradient.min && position <= gradient.max)\n                    return gradient.gradient((position - gradient.min) / (gradient.max - gradient.min));\n            throw new RangeError(`Invalid gradient position: ${position}`);\n        };\n    }\n\n    /**\n     * Rounds the images corners\n     * @param {number} [radius=min(width,height)/4] The radius of the corners\n     * @return {Image}\n     */\n    roundCorners(radius = Math.min(this.width, this.height) / 4) {\n        const radSquared = radius ** 2;\n        for (let x = 1; x <= radius; x++) {\n            const xRad = (x - radius) ** 2;\n            for (let y = 1; y <= radius; y++) {\n                if (xRad + (y - radius) ** 2 > radSquared)\n                    this.bitmap[((y - 1) * this.width + x - 1) * 4 + 3] = 0;\n            }\n        }\n\n        for (let x = 1; x <= radius; x++) {\n            const xRad = (x - radius) ** 2;\n            for (let y = this.height - radius; y <= this.height; y++) {\n                if (xRad + ((this.height - y) - radius) ** 2 > radSquared)\n                    this.bitmap[((y - 1) * this.width + x - 1) * 4 + 3] = 0;\n            }\n        }\n\n        for (let x = this.width - radius; x <= this.width; x++) {\n            const xRad = ((this.width - x) - radius) ** 2;\n            for (let y = 1; y <= radius; y++) {\n                if (xRad + (y - radius) ** 2 > radSquared)\n                    this.bitmap[((y - 1) * this.width + x - 1) * 4 + 3] = 0;\n            }\n        }\n\n        for (let x = this.width - radius; x <= this.width; x++) {\n            const xRad = ((this.width - x) - radius) ** 2;\n            for (let y = this.height - radius; y <= this.height; y++) {\n                if (xRad + ((this.height - y) - radius) ** 2 > radSquared)\n                    this.bitmap[((y - 1) * this.width + x - 1) * 4 + 3] = 0;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * @private\n     */\n    static __gradient__(startColor, endColor) {\n        const sr = startColor >>> 24;\n        const sg = startColor >> 16 & 0xff;\n        const sb = startColor >> 8 & 0xff;\n        const sa = startColor & 0xff;\n        const er = (endColor >>> 24) - sr;\n        const eg = (endColor >> 16 & 0xff) - sg;\n        const eb = (endColor >> 8 & 0xff) - sb;\n        const ea = (endColor & 0xff) - sa;\n\n        return position => {\n            const r = sr + position * er;\n            const g = sg + position * eg;\n            const b = sb + position * eb;\n            const a = sa + position * ea;\n            return (((r & 0xff) << 24) | ((g & 0xff) << 16) | ((b & 0xff) << 8) | (a & 0xff));\n        };\n    }\n\n    fisheye(radius = 2) {\n        const r = new Image(this.width, this.height);\n\n        const w = this.width;\n        const h = this.height;\n        const tu32 = this.__u32__;\n        const ru32 = r.__u32__;\n        const iw = 1 / w;\n        const ih = 1 / h;\n\n        for (const [x, y] of this) {\n            const xco = x * iw - .5;\n            const yco = y * ih - .5;\n            const dfc = Math.sqrt(xco ** 2 + yco ** 2);\n            const dis = 2 * dfc ** radius;\n            const nx = ((dis * xco / dfc + 0.5) * w) | 0;\n            const ny = ((dis * yco / dfc + 0.5) * h) | 0;\n\n            if (nx < 1 || nx > w || ny < 1 || ny > h || isNaN(nx) || isNaN(ny))\n                continue;\n\n            ru32[y * w + x] = tu32[w * ny + nx];\n        }\n\n        const cO = tu32.length * .5 + w / 2;\n        ru32[cO] = tu32[cO];\n\n        return this.__apply__(r);\n    }\n\n    /**\n     * Encodes the image into a PNG\n     * @param {number} compression The compression level to use (0-3)\n     * @return {Promise<Uint8Array>} The encoded data\n     */\n    async encode(compression = 1) {\n        return await png.encode(this.bitmap, {width: this.width, height: this.height, level: compression, channels: 4});\n    }\n\n    /**\n     * Encodes the image into a JPEG\n     * @param {number} [quality=90] The JPEG quality to use\n     * @return {Promise<Uint8Array>}\n     */\n    async encodeJPEG(quality = 90) {\n        await jpeglib.init();\n        return jpeglib.encode(this.bitmap, this.width, this.height, Math.max(1, Math.min(100, quality)));\n    }\n\n    /**\n     * Decodes an image (PNG, JPEG or TIFF)\n     * @param {Buffer|Uint8Array} data The binary data to decode\n     * @return {Promise<Image>} The decoded image\n     */\n    static async decode(data) {\n        let image;\n\n        let view;\n        if (!ArrayBuffer.isView(data)) {\n            data = new Uint8Array(data);\n            view = new DataView(data.buffer);\n        } else {\n            data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n            view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n        }\n\n        if (ImageType.isPNG(view)) { // PNG\n            const {width, height, pixels} = await png.decode(data);\n            image = new Image(width, height);\n            image.bitmap.set(pixels);\n        } else if (ImageType.isJPEG(view)) { // JPEG\n            await jpeglib.init();\n            const framebuffer = jpeglib.decode(data);\n\n            const width = framebuffer.width;\n            const height = framebuffer.height;\n            const pixelType = framebuffer.format;\n\n            image = new Image(width, height);\n            const buffer = framebuffer.buffer;\n\n            if (pixelType === 0) {\n                const view = new DataView(image.bitmap.buffer);\n\n                for (let i = 0; i < buffer.length; i++) {\n                    const pixel = buffer[i];\n                    view.setUint32(i * 4, pixel << 24 | pixel << 16 | pixel << 8 | 0xff, false);\n                }\n            } else if (pixelType === 1) {\n                image.bitmap.fill(0xff);\n                for (let i = 0; i < width * height; i++)\n                    image.bitmap.set(buffer.subarray(i * 3, i * 3 + 3), i * 4);\n            } else if (pixelType === 2) {\n                for (let i = 0; i < buffer.length; i += 4) {\n                    image.bitmap[i] = 0xff * (1 - buffer[i] / 0xff) * (1 - buffer[i + 3] / 0xff);\n                    image.bitmap[i + 1] = 0xff * (1 - buffer[i + 1] / 0xff) * (1 - buffer[i + 3] / 0xff);\n                    image.bitmap[i + 2] = 0xff * (1 - buffer[i + 2] / 0xff) * (1 - buffer[i + 3] / 0xff);\n                    image.bitmap[i + 3] = 0xff;\n                }\n            }\n        } else if (ImageType.isTIFF(view)) { // TIFF\n            await tifflib.init();\n            const framebuffer = tifflib.decode(data);\n            image = new Image(framebuffer.width, framebuffer.height);\n\n            image.bitmap.set(framebuffer.buffer);\n        } else throw new Error('Unsupported image type');\n\n        return image;\n    }\n\n    /**\n     * Scale the SVG by the given amount. For use with {@link Image.renderSVG}\n     * @return {number}\n     */\n    static get SVG_MODE_SCALE() {\n        return 1;\n    }\n\n    /**\n     * Scale the SVG to fit the given width. For use with {@link Image.renderSVG}\n     * @return {number}\n     */\n    static get SVG_MODE_WIDTH() {\n        return 2;\n    }\n\n    /**\n     * Scale the SVG to fit the given height. For use with {@link Image.renderSVG}\n     * @return {number}\n     */\n    static get SVG_MODE_HEIGHT() {\n        return 3;\n    }\n\n    /**\n     * Creates a new image from the given SVG\n     * @param {string} svg The SVG content\n     * @param {number} size The size to use\n     * @param {number} mode The SVG resizing mode to use (one of {@link SVG_MODE_SCALE}, {@link SVG_MODE_WIDTH}, {@link SVG_MODE_HEIGHT})\n     * @return {Promise<Image>} The rendered SVG graphic\n     */\n    static async renderSVG(svg, size = 1, mode = this.SVG_MODE_SCALE) {\n        if (![this.SVG_MODE_WIDTH, this.SVG_MODE_HEIGHT, this.SVG_MODE_SCALE].includes(mode))\n            throw new Error('Invalid SVG scaling mode');\n\n        if (mode === this.SVG_MODE_SCALE && size <= 0)\n            throw new RangeError('SVG scale must be > 0');\n        if (mode !== this.SVG_MODE_SCALE && size < 1)\n            throw new RangeError('SVG size must be >= 1');\n\n        if (typeof svg === 'string') svg = new TextEncoder().encode(svg);\n\n        await svglib.init();\n        const framebuffer = svglib.rasterize(svg, mode, size);\n        const image = new Image(framebuffer.width, framebuffer.height);\n\n        image.bitmap.set(framebuffer.buffer);\n\n        return image;\n    }\n\n    /**\n     * Creates a new image containing the rendered text.\n     * @param {Uint8Array} font TrueType (ttf/ttc) or OpenType (otf) font buffer to use\n     * @param {number} scale Font size to use\n     * @param {string} text Text to render\n     * @param {number} color Text color to use\n     * @param {TextLayout} layout The text layout to use\n     * @return {Promise<Image>} The rendered text\n     */\n    static async renderText(font, scale, text, color = 0xffffffff, layout = new TextLayout()) {\n        await fontlib.init();\n        font = new fontlib.Font(scale, font);\n        const [r, g, b, a] = Image.colorToRGBA(color);\n\n        const layoutOptions = new fontlib.Layout();\n        layoutOptions.reset({\n            max_width: layout.maxWidth,\n            max_height: layout.maxHeight,\n            wrap_style: layout.wrapStyle,\n            vertical_align: layout.verticalAlign,\n            horizontal_align: layout.horizontalAlign,\n            wrap_hard_breaks: layout.wrapHardBreaks\n        });\n\n        layoutOptions.append(font, text, {scale});\n        const framebuffer = layoutOptions.rasterize(r, g, b);\n        const image = new Image(framebuffer.width, framebuffer.height);\n\n        image.bitmap.set(framebuffer.buffer);\n\n        if (image.height > layout.maxHeight)\n            image.crop(0, 0, image.width, Math.floor(layoutOptions.lines() / image.height * layout.maxHeight) * (image.height / layoutOptions.lines()));\n\n        font.free();\n        layoutOptions.free();\n        return image.opacity(a / 0xff);\n    }\n\n}\n\n/**\n * Represents a frame in a GIF\n * @extends Image\n */\nclass Frame extends Image {\n    /**\n     * Creates a new, blank frame\n     * @param {number} width\n     * @param {number} height\n     * @param {number} [duration = 100] The frames duration (in ms)\n     * @param {number} [xOffset=0] The frames offset on the x-axis\n     * @param {number} [yOffset=0] The frames offset on the y-axis\n     * @return {Frame}\n     */\n    constructor(width, height, duration = 100, xOffset = 0, yOffset = 0) {\n        if (isNaN(duration) || duration < 0)\n            throw new RangeError('Invalid frame duration');\n\n        super(width, height);\n        this.duration = duration;\n        this.xOffset = xOffset;\n        this.yOffset = yOffset;\n    }\n\n    toString() {\n        return `Frame<${this.width}x${this.height}x${this.duration}ms>`;\n    }\n\n    /**\n     * Converts an Image instance to a Frame, cloning it in the process\n     * @param {Image} image The image to create the frame from\n     * @param {number} [duration = 100] The frames duration (in ms)\n     * @param {number} [xOffset=0] The frames offset on the x-axis\n     * @param {number} [yOffset=0] The frames offset on the y-axis\n     * @return {Frame}\n     */\n    static from(image, duration, xOffset, yOffset) {\n        if (!(image instanceof Image))\n            throw new TypeError('Invalid image passed');\n        const frame = new Frame(image.width, image.height, duration, xOffset, yOffset);\n        frame.bitmap.set(image.bitmap);\n\n        return frame;\n    }\n}\n\n/**\n * Represents a GIF image as an array of frames\n * @extends Array<Frame>\n */\nclass GIF extends Array {\n    /**\n     * Creates a new GIF image.\n     * @param {Frame[]} frames The frames to create the GIF from\n     * @param {number} [loopCount=0] How often to loop the GIF for (-1 = unlimited)\n     * @property {number} loopCount How often the GIF will loop for\n     */\n    constructor(frames, loopCount = -1) {\n        super(...frames);\n\n        this.width = Math.max(...frames.map(frame => frame.width));\n        this.height = Math.max(...frames.map(frame => frame.height));\n\n        for (const frame of this)\n            if (!(frame instanceof Frame))\n                throw new TypeError(`Frame ${this.indexOf(frame)} is not an instance of Frame`);\n\n        if (loopCount < -1 || isNaN(loopCount))\n            throw new RangeError('Invalid loop count');\n\n        this.loopCount = loopCount;\n    }\n\n    toString() {\n        return `GIF<${this.width}x${this.height}x${this.duration}ms>`;\n    }\n\n    * [Symbol.iterator]() {\n        for (let i = 0; i < this.length; i++)\n            yield this[i];\n    }\n\n    /**\n     * The GIFs duration (in ms)\n     * @return {number}\n     */\n    get duration() {\n        return this.reduce((acc, frame) => acc + frame.duration, 0);\n    }\n\n    /**\n     * Encodes the image into a GIF\n     * @param {number} [quality=10] GIF quality ((best) 1..30 (worst))\n     * @return {Promise<Uint8Array>} The encoded data\n     */\n    async encode(quality = 10) {\n        await giflib.init();\n        const encoder = new giflib.Encoder(this.width, this.height, this.loopCount);\n\n        for (const frame of this) {\n            if (!(frame instanceof Frame)) throw new Error('GIF contains invalid frames');\n            encoder.add(frame.xOffset, frame.yOffset, ~~(frame.duration / 10), frame.width, frame.height, frame.bitmap, quality);\n        }\n\n        return encoder.u8();\n    }\n\n    /**\n     * Decodes a GIF image\n     * @param {Buffer|Uint8Array} data The binary data to decode\n     * @param {boolean} [onlyExtractFirstFrame=false] Whether to end GIF decoding after the first frame\n     * @return {Promise<GIF>} The decoded GIF\n     */\n    static async decode(data, onlyExtractFirstFrame = false) {\n        let image;\n\n        let view;\n        if (!ArrayBuffer.isView(data)) {\n            data = new Uint8Array(data);\n            view = new DataView(data.buffer);\n        } else {\n            data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n            view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n        }\n\n        await giflib.init();\n\n        if (ImageType.isGIF(view)) { // GIF\n            await giflib.init();\n            const decoder = new giflib.Decoder(data);\n            let frames = [];\n            for (const frameData of decoder.frames()) {\n                const frame = new Frame(frameData.width, frameData.height, frameData.delay * 10, frameData.x, frameData.y);\n                frame.bitmap.set(frameData.buffer);\n                frames.push(frame);\n\n                if (onlyExtractFirstFrame)\n                    break;\n            }\n\n            decoder.free();\n\n            image = new GIF(frames);\n        } else throw new Error('Unsupported image type');\n\n        return image;\n    }\n}\n\nclass TextLayout {\n    /**\n     * Layout options for {@link renderText}\n     * @param {object} options\n     * @param {number} [options.maxWidth=Infinity] The texts max width\n     * @param {number} [options.maxHeight=Infinity] The texts max height\n     * @param {string} [options.wrapStyle='string'] The texts wrap style when reaching the max width (word, char)\n     * @param {string} [options.verticalAlign='left'] The vertical align mode (left, center, right)\n     * @param {string} [options.horizontalAlign='top'] The horizontal align mode (top, middle, bottom)\n     * @param {string} [options.wrapHardBreaks=true] Whether to force wrap at new line characters\n     */\n    constructor(options) {\n        const {maxWidth, maxHeight, wrapStyle, verticalAlign, horizontalAlign, wrapHardBreaks} = options ?? {};\n\n        this.maxWidth = maxWidth ?? Infinity;\n        if (isNaN(this.maxWidth) || this.maxWidth < 1)\n            throw new RangeError('Invalid maxWidth');\n\n        this.maxHeight = maxHeight ?? Infinity;\n        if (isNaN(this.maxHeight) || this.maxHeight < 1)\n            throw new RangeError('Invalid maxHeight');\n\n        this.wrapStyle = wrapStyle ?? 'word';\n        if (!['word', 'char'].includes(this.wrapStyle))\n            throw new RangeError('Invalid wrapStyle');\n\n        this.verticalAlign = verticalAlign ?? 'left';\n        if (!['left', 'center', 'right'].includes(this.verticalAlign))\n            throw new RangeError('Invalid verticalAlign');\n\n        this.horizontalAlign = horizontalAlign ?? 'top';\n        if (!['top', 'middle', 'bottom'].includes(this.horizontalAlign))\n            throw new RangeError('Invalid horizontalAlign');\n\n        this.wrapHardBreaks = wrapHardBreaks ?? true;\n        if (typeof this.wrapHardBreaks !== 'boolean')\n            throw new TypeError('Invalid wrapHardBreaks');\n    }\n}\n\nclass ImageType {\n    /**\n     * Gets an images type (png, jpeg, tiff, gif)\n     * @param {Buffer|Uint8Array} data The image binary to get the type of\n     * @returns {string|null} The image type (png, jpeg, tiff, gif, null)\n     */\n    static getType(data) {\n        let view;\n        if (!ArrayBuffer.isView(data)) {\n            data = new Uint8Array(data);\n            view = new DataView(data.buffer);\n        } else {\n            data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n            view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n        }\n\n        if (this.isPNG(view)) return 'png';\n        if (this.isJPEG(view)) return 'jpeg';\n        if (this.isTIFF(view)) return 'tiff';\n        if (this.isGIF(view)) return 'gif';\n        return null;\n    }\n\n    /**\n     * @param {DataView} view\n     * @returns {boolean}\n     */\n    static isPNG(view) {\n        return view.getUint32(0, false) === MAGIC_NUMBERS.PNG;\n    }\n\n    /**\n     * @param {DataView} view\n     * @returns {boolean}\n     */\n    static isJPEG(view) {\n        return (view.getUint32(0, false) >>> 8) === MAGIC_NUMBERS.JPEG;\n    }\n\n    /**\n     * @param {DataView} view\n     * @returns {boolean}\n     */\n    static isTIFF(view) {\n        return view.getUint32(0, false) === MAGIC_NUMBERS.TIFF;\n    }\n\n    /**\n     * @param {DataView} view\n     * @returns {boolean}\n     */\n    static isGIF(view) {\n        return (view.getUint32(0, false) >>> 8) === MAGIC_NUMBERS.GIF;\n    }\n}\n\n/**\n * Decodes the given image binary\n * @param {Uint8Array|Buffer} data The image data\n * @param {boolean} [onlyExtractFirstFrame] Whether to end GIF decoding after the first frame\n * @returns {Promise<GIF|Image>} The decoded image\n */\nfunction decode(data, onlyExtractFirstFrame) {\n    const type = ImageType.getType(data);\n\n    if (type === 'gif')\n        return GIF.decode(data, onlyExtractFirstFrame);\n    return Image.decode(data);\n}\n\nmodule.exports = {Image, GIF, Frame, TextLayout, ImageType, decode};\n","module.exports = class Buffer {\n    static concat(...arrays) {\n        const array = new Uint8Array(\n            arrays.reduce((length, array) => length + array.length, 0)\n        );\n\n        let offset = 0;\n        for (const x of arrays) {\n            array.set(x, offset);\n            offset += x.length;\n        }\n\n        return array;\n    }\n};","const table = new Uint32Array([\n    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,\n    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\n    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,\n    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,\n    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\n    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,\n    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\n    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,\n    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\n    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,\n    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,\n    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\n    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,\n    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\n    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,\n    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\n    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,\n    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,\n    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\n    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,\n    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\n    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,\n    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\n    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,\n    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\n    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,\n    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\n    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,\n    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\n    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,\n    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\n    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,\n    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\n    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,\n    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\n    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,\n    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,\n    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\n    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D]);\n\nmodule.exports = function crc32(buffer) {\n    let offset = 0;\n    let crc = 0xFFFFFFFF;\n\n    while (offset < buffer.length - 4) {\n        crc = table[(crc ^ buffer[offset++]) & 0xff] ^ (crc >>> 8);\n        crc = table[(crc ^ buffer[offset++]) & 0xff] ^ (crc >>> 8);\n        crc = table[(crc ^ buffer[offset++]) & 0xff] ^ (crc >>> 8);\n        crc = table[(crc ^ buffer[offset++]) & 0xff] ^ (crc >>> 8);\n    }\n\n    while (offset < buffer.length) {\n        crc = table[(crc ^ buffer[offset++]) & 0xff] ^ (crc >>> 8);\n    }\n\n    return (crc ^ 0xFFFFFFFF) >>> 0;\n};","/* global SharedArrayBuffer */\nconst crc32 = require('./crc32.js');\nconst Buffer = require('./buffer');\nconst {init, compress, decompress} = require('./wasm/zlib.js');\n\nconst __IHDR__ = new Uint8Array([73, 72, 68, 82]);\nconst __IDAT__ = new Uint8Array([73, 68, 65, 84]);\nconst __IEND__ = new Uint8Array([73, 69, 78, 68]);\nconst __IEND_CRC__ = crc32(new Uint8Array([73, 69, 78, 68]));\nconst HEAD = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);\n\nconst color_types = {\n    GREYSCALE: 0,\n    TRUECOLOR: 2,\n    INDEXED_COLOR: 3,\n    GREYSCALE_ALPHA: 4,\n    TRUECOLOR_ALPHA: 6\n};\n\nconst channels_to_color_type = {\n    1: color_types.GREYSCALE,\n    2: color_types.GREYSCALE_ALPHA,\n\n    3: color_types.TRUECOLOR,\n    4: color_types.TRUECOLOR_ALPHA\n};\n\nmodule.exports = {\n    async encode(data, {width, height, channels, depth = 8, level = 0}) {\n        let offset = 0;\n        let tmp_offset = 0;\n        const row_length = width * channels;\n        const tmp = new Uint8Array(height + data.length);\n\n        while (offset < data.length) {\n            tmp[tmp_offset++] = 0;\n            tmp.set(data.subarray(offset, (offset += row_length)), tmp_offset);\n\n            tmp_offset += row_length;\n        }\n\n        await init();\n        const compressed = compress(tmp, level);\n        const array = new Uint8Array(49 + HEAD.length + compressed.length);\n\n        array[26] = 0;\n        array[27] = 0;\n        array[28] = 0;\n        array[24] = depth;\n        array.set(HEAD, 0);\n        array.set(__IHDR__, 12);\n        array.set(__IDAT__, 37);\n        array.set(compressed, 41);\n        array.set(__IEND__, 49 + compressed.length);\n        array[25] = channels_to_color_type[channels];\n\n        const view = new DataView(array.buffer);\n\n        view.setUint32(8, 13);\n        view.setUint32(16, width);\n        view.setUint32(20, height);\n        view.setUint32(33, compressed.length);\n        view.setUint32(45 + compressed.length, 0);\n        view.setUint32(53 + compressed.length, __IEND_CRC__);\n        view.setUint32(29, crc32(new Uint8Array(array.buffer, 12, 17)));\n        view.setUint32(41 + compressed.length, crc32(new Uint8Array(array.buffer, 37, 4 + compressed.length)));\n\n        return array;\n    },\n    async decode(array) {\n        let view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n\n        const width = view.getUint32(16);\n        const height = view.getUint32(20);\n        const bpc = array[24];\n        const pixel_type = array[25];\n        let channels = ({3: 1, 0: 1, 4: 2, 2: 3, 6: 4})[pixel_type];\n        const bytespp = channels * bpc / 8;\n\n        const row_length = width * bytespp;\n        let pixels = new Uint8Array(height * row_length);\n\n        let offset = 0;\n        let p_offset = 0;\n\n        let c_offset = 33;\n        const chunks = [];\n\n        let palette, alphaPalette;\n\n        let type;\n        while (type !== 1229278788) {\n            type = view.getUint32(4 + c_offset);\n\n            // IDAT\n            if (type === 1229209940)\n                chunks.push(array.subarray(8 + c_offset, 8 + c_offset + view.getUint32(c_offset)));\n            else if (type === 1347179589) { // PLTE\n                if (palette)\n                    throw new Error('PLTE can only occur once in an image');\n                palette = new Uint32Array(view.getUint32(c_offset));\n                for (let pxlOffset = 0; pxlOffset < palette.length * 8; pxlOffset += 3)\n                    palette[pxlOffset / 3] = array[8 + c_offset + pxlOffset] << 24 | array[8 + c_offset + pxlOffset + 1] << 16 | array[8 + c_offset + pxlOffset + 2] << 8 | 0xff;\n            } else if (type === 1951551059) { // tRNS\n                if (alphaPalette)\n                    throw new Error('tRNS can only occur once in an image');\n                alphaPalette = new Uint8Array(view.getUint32(c_offset));\n                for (let i = 0; i < alphaPalette.length; i++)\n                    alphaPalette[i] = array[8 + c_offset + i];\n            }\n\n            c_offset += 4 + 4 + 4 + view.getUint32(c_offset);\n        }\n\n        await init();\n        array = decompress(chunks.length === 1 ? chunks[0] : Buffer.concat(...chunks));\n\n        while (offset < array.byteLength) {\n            const filter = array[offset++];\n            const slice = array.subarray(offset, offset += row_length);\n\n            if (0 === filter) pixels.set(slice, p_offset);\n            else if (1 === filter) this.filter_1(slice, pixels, p_offset, bytespp, row_length);\n            else if (2 === filter) this.filter_2(slice, pixels, p_offset, bytespp, row_length);\n            else if (3 === filter) this.filter_3(slice, pixels, p_offset, bytespp, row_length);\n            else if (4 === filter) this.filter_4(slice, pixels, p_offset, bytespp, row_length);\n\n            p_offset += row_length;\n        }\n\n        if (pixel_type === 3) {\n            if (!palette)\n                throw new Error('Indexed color PNG has no PLTE');\n\n            if (alphaPalette)\n                for (let i = 0; i < alphaPalette.length; i++)\n                    palette[i] &= 0xffffff00 | alphaPalette[i];\n\n            channels = 4;\n            const newPixels = new Uint8Array(width * height * 4);\n            const pixelView = new DataView(newPixels.buffer, newPixels.byteOffset, newPixels.byteLength);\n            for (let i = 0; i < pixels.length; i++)\n                pixelView.setUint32(i * 4, palette[pixels[i]], false);\n            pixels = newPixels;\n        }\n\n        if (bpc !== 8) {\n            const newPixels = new Uint8Array(pixels.length / bpc * 8);\n            for (let i = 0; i < pixels.length; i += 2)\n                newPixels[i / 2] = pixels[i];\n            pixels = newPixels;\n        }\n\n        if (channels !== 4) {\n            const newPixels = new Uint8Array(width * height * 4);\n            const view = new DataView(newPixels.buffer);\n\n            if (channels === 1) {\n                for (let i = 0; i < width * height; i++) {\n                    const pixel = pixels[i];\n                    view.setUint32(i * 4, pixel << 24 | pixel << 16 | pixel << 8 | 0xff, false);\n                }\n            } else if (channels === 2) {\n                for (let i = 0; i < width * height * 2; i += 2) {\n                    const pixel = pixels[i];\n                    view.setUint32(i * 2, pixel << 24 | pixel << 16 | pixel << 8 | pixels[i + 1], false);\n                }\n            } else if (channels === 3) {\n                newPixels.fill(0xff);\n                for (let i = 0; i < width * height; i++)\n                    newPixels.set(pixels.subarray(i * 3, i * 3 + 3), i * 4);\n            }\n\n            pixels = newPixels;\n        }\n\n        return {width, height, pixels};\n    },\n\n    filter_1(slice, pixels, p_offset, bytespp, row_length) {\n        let i = 0;\n        while (i < bytespp) pixels[i + p_offset] = slice[i++];\n        while (i < row_length) pixels[i + p_offset] = slice[i] + pixels[i++ + p_offset - bytespp];\n    },\n\n    filter_2(slice, pixels, p_offset, bytespp, row_length) {\n        if (0 === p_offset) pixels.set(slice, p_offset);\n        else {\n            let i = 0;\n            while (i < row_length) pixels[i + p_offset] = slice[i] + pixels[i++ + p_offset - row_length];\n        }\n    },\n\n    filter_3(slice, pixels, p_offset, bytespp, row_length) {\n        let i = 0;\n\n        if (0 === p_offset) {\n            while (i < bytespp) pixels[i] = slice[i++];\n            while (i < row_length) pixels[i] = slice[i] + (pixels[i++ - bytespp] >> 1);\n        } else {\n            while (i < bytespp) pixels[i + p_offset] = slice[i] + (pixels[i++ + p_offset - row_length] >> 1);\n            while (i < row_length) pixels[i + p_offset] = slice[i] + (pixels[i + p_offset - bytespp] + pixels[i++ + p_offset - row_length] >> 1);\n        }\n    },\n\n    filter_4(slice, pixels, p_offset, bytespp, row_length) {\n        let i = 0;\n\n        if (0 === p_offset) {\n            while (i < bytespp) pixels[i] = slice[i++];\n            while (i < row_length) pixels[i] = slice[i] + pixels[i++ - bytespp];\n        } else {\n            while (i < bytespp) pixels[i + p_offset] = slice[i] + pixels[i++ + p_offset - row_length];\n\n            while (i < row_length) {\n                const a = pixels[i + p_offset - bytespp];\n                const b = pixels[i + p_offset - row_length];\n                const c = pixels[i + p_offset - bytespp - row_length];\n\n                const p = a + b - c;\n                const pa = Math.abs(p - a);\n                const pb = Math.abs(p - b);\n                const pc = Math.abs(p - c);\n\n                pixels[i + p_offset] = slice[i++] + ((pa <= pb && pa <= pc) ? a : ((pb <= pc) ? b : c));\n            }\n        }\n    }\n};\n","const {version} = require('../../package.json');\n\nlet wasm;\nlet registry = null;\n\nclass mem {\n  static length() { return wasm.wlen(); }\n  static alloc(size) { return wasm.walloc(size); }\n  static free(ptr, size) { return wasm.wfree(ptr, size); }\n  static u8(ptr, size) { return new Uint8Array(wasm.memory.buffer, ptr, size); }\n  static u32(ptr, size) { return new Uint32Array(wasm.memory.buffer, ptr, size); }\n\n  static copy_and_free(ptr, size) {\n    let slice = mem.u8(ptr, size).slice();\n    return (wasm.wfree(ptr, size), slice);\n  }\n}\n\nconst encode_utf8 = 'Deno' in globalThis ? Deno.core.encode : (() => {\n  const encoder = new TextEncoder();\n  return string => encoder.encode(string);\n})();\n\nconst decode_utf8 = 'Deno' in globalThis ? Deno.core.decode : (() => {\n  const decoder = new TextDecoder();\n  return buffer => decoder.decode(buffer);\n})();\n\nif ('FinalizationRegistry' in globalThis) {\n  registry = new FinalizationRegistry(([t, ptr]) => {\n    if (t === 0) wasm.font_free(ptr);\n    if (t === 1) wasm.layout_free(ptr);\n  });\n}\n\nclass Font {\n  constructor(scale, buffer) {\n    this.scale = scale;\n    const ptr = mem.alloc(buffer.length);\n    mem.u8(ptr, buffer.length).set(buffer);\n    this.ptr = wasm.font_new(ptr, buffer.length, scale);\n\n    if (!this.ptr) throw new Error('invalid font');\n    if (registry) registry.register(this, [0, this.ptr], this);\n  }\n\n  free() {\n    this.ptr = wasm.font_free(this.ptr);\n    if (registry) registry.unregister(this);\n  }\n\n  has(char) {\n    return wasm.font_has(this.ptr, String.prototype.charCodeAt.call(char, 0));\n  }\n\n  metrics(char, scale = this.scale) {\n    const ptr = wasm.font_metrics(this.ptr, String.prototype.charCodeAt.call(char, 0), scale);\n    const metrics = JSON.parse(decode_utf8(mem.u8(wasm.font_metrics_buffer(ptr), mem.length())));\n\n    return (wasm.font_metrics_free(ptr), metrics);\n  }\n\n  rasterize(char, scale = this.scale) {\n    const ptr = wasm.font_rasterize(this.ptr, String.prototype.charCodeAt.call(char, 0), scale);\n\n    const glyph = {\n      buffer: mem.u8(wasm.font_rasterize_buffer(ptr), mem.length()).slice(),\n      metrics: JSON.parse(decode_utf8(mem.u8(wasm.font_rasterize_metrics(ptr), mem.length()))),\n    }\n\n    return (wasm.font_rasterize_free(ptr), glyph);\n  }\n}\n\nclass Layout {\n  constructor() {\n    this.ptr = wasm.layout_new();\n    if (registry) this.refs = [];\n    if (registry) registry.register(this, [1, this.ptr], this);\n  }\n\n  clear() {\n    wasm.layout_clear(this.ptr);\n    if (registry) this.refs.length = 0;\n  }\n\n  lines() {\n    return wasm.layout_lines(this.ptr);\n  }\n\n  free() {\n    if (registry) this.refs.length = 0;\n    this.ptr = wasm.layout_free(this.ptr);\n    if (registry) registry.unregister(this);\n  }\n\n  reset(options = {}) {\n    options = encode_utf8(JSON.stringify(options));\n\n    if (registry) this.refs.length = 0;\n    const ptr = mem.alloc(options.length);\n    mem.u8(ptr, options.length).set(options);\n    wasm.layout_reset(this.ptr, ptr, options.length);\n  }\n\n  append(font, text, init) {\n    text = encode_utf8(text);\n    const options = init || {};\n    if (registry) this.refs.push(font);\n    const ptr = mem.alloc(text.length);\n    mem.u8(ptr, text.length).set(text);\n    const has_color = ('r' in options) || ('g' in options) || ('b' in options);\n    wasm.layout_append(this.ptr, font.ptr, ptr, text.length, options.scale == null ? font.scale : options.scale, has_color, options.r, options.g, options.b);\n  }\n\n  rasterize(r, g, b) {\n    const ptr = wasm.layout_rasterize(this.ptr, r, g, b);\n\n    const framebuffer = {\n      width: wasm.layout_rasterize_width(ptr),\n      height: wasm.layout_rasterize_height(ptr),\n      buffer: mem.u8(wasm.layout_rasterize_buffer(ptr), mem.length()).slice(),\n    }\n\n    return (wasm.layout_rasterize_free(ptr), framebuffer);\n  }\n}\n\nmodule.exports = {\n  Font,\n  Layout,\n\n  async init() {\n    if (wasm) return;\n    const streaming = 'compileStreaming' in WebAssembly;\n    const module = await WebAssembly[!streaming ? 'compile' : 'compileStreaming'](await fetch(`https://unpkg.com/imagescript@${version}/utils/wasm/font.wasm`).then(x => streaming ? x : x.arrayBuffer()));\n    const instance = await WebAssembly.instantiate(module);\n  \n    wasm = instance.exports;\n  },\n}\n","const {version} = require('../../package.json');\n\nlet wasm;\nconst streams = new Map;\n\nclass mem {\n  static length() { return wasm.wlen(); }\n  static alloc(size) { return wasm.walloc(size); }\n  static free(ptr, size) { return wasm.wfree(ptr, size); }\n  static u8(ptr, size) { return new Uint8Array(wasm.memory.buffer, ptr, size); }\n  static u32(ptr, size) { return new Uint32Array(wasm.memory.buffer, ptr, size); }\n\n  static copy_and_free(ptr, size) {\n    let slice = mem.u8(ptr, size).slice();\n    return (wasm.wfree(ptr, size), slice);\n  }\n}\n\nclass Encoder {\n  constructor(width, height, loops = -1) {\n    this.slices = [];\n    streams.set(0, this);\n    this.ptr = wasm.encoder_new(0, width, height, loops);\n  }\n\n  cb(buffer) {\n    this.slices.push(buffer);\n  }\n\n  free() {\n    this.ptr = wasm.encoder_free(this.ptr);\n    streams.delete(0);\n  }\n\n  u8() {\n    this.free();\n    let offset = 0;\n    const u8 = new Uint8Array(this.slices.reduce((sum, array) => sum + array.length, 0));\n\n    for (const x of this.slices) {\n      u8.set(x, offset);\n      offset += x.length;\n    }\n\n    return u8;\n  }\n\n  add(x, y, delay, width, height, buffer, quality) {\n    const ptr = mem.alloc(buffer.length);\n    mem.u8(ptr, buffer.length).set(buffer);\n    wasm.encoder_add(this.ptr, ptr, buffer.length, x, y, width, height, delay, quality);\n  }\n}\n\nclass Decoder {\n  constructor(buffer, limit = 0) {\n    const bptr = mem.alloc(buffer.length);\n    mem.u8(bptr, buffer.length).set(buffer);\n    this.ptr = wasm.decoder_new(bptr, buffer.length, limit);\n    if (0 === this.ptr) throw new Error('gif: failed to parse gif header');\n\n    this.width = wasm.decoder_width(this.ptr);\n    this.height = wasm.decoder_height(this.ptr);\n  }\n\n  free() {\n    this.ptr = wasm.decoder_free(this.ptr);\n  }\n\n  *frames() {\n    let frame;\n    while (frame = this.frame()) yield frame;\n  }\n\n  frame() {\n    const ptr = wasm.decoder_frame(this.ptr);\n\n    if (1 === ptr) return null;\n    if (0 === ptr) throw (this.free(), new Error('gif: failed to decode frame'));\n\n    const framebuffer = {\n      x: wasm.decoder_frame_x(ptr),\n      y: wasm.decoder_frame_y(ptr),\n      delay: wasm.decoder_frame_delay(ptr),\n      width: wasm.decoder_frame_width(ptr),\n      height: wasm.decoder_frame_height(ptr),\n      buffer: mem.u8(wasm.decoder_frame_buffer(ptr), mem.length()).slice(),\n    };\n\n    return (wasm.decoder_frame_free(ptr), framebuffer);\n  }\n}\n\nmodule.exports = {\n  Encoder,\n  Decoder,\n\n  async init() {\n\t\tif (wasm) return;\n\t\tconst streaming = 'compileStreaming' in WebAssembly;\n\t\tconst module = await WebAssembly[!streaming ? 'compile' : 'compileStreaming'](await fetch(`https://unpkg.com/imagescript@${version}/utils/wasm/gif.wasm`).then(x => streaming ? x : x.arrayBuffer()));\n    const instance = await WebAssembly.instantiate(module, {\n      env: {\n        push_to_stream(id, ptr) {\n          streams.get(id).cb(mem.u8(ptr, mem.length()).slice());\n        }\n      }\n    });\n  \n    wasm = instance.exports;\n  }\n}\n","const {version} = require('../../package.json');\n\nlet wasm;\n\nclass mem {\n  static length() { return wasm.wlen(); }\n  static alloc(size) { return wasm.walloc(size); }\n  static free(ptr, size) { return wasm.wfree(ptr, size); }\n  static u8(ptr, size) { return new Uint8Array(wasm.memory.buffer, ptr, size); }\n  static u32(ptr, size) { return new Uint32Array(wasm.memory.buffer, ptr, size); }\n\n  static copy_and_free(ptr, size) {\n    let slice = mem.u8(ptr, size).slice();\n    return (wasm.wfree(ptr, size), slice);\n  }\n}\n\nfunction encode(buffer, width, height, quality) {\n  const ptr = mem.alloc(buffer.length);\n  mem.u8(ptr, buffer.length).set(buffer);\n  return mem.copy_and_free(wasm.encode(ptr, width, height, quality), mem.length());\n}\n\nfunction decode(buffer, width, height) {\n  const bptr = mem.alloc(buffer.length);\n  mem.u8(bptr, buffer.length).set(buffer);\n  const ptr = wasm.decode(bptr, buffer.length, width, height);\n\n  if (0 === ptr) throw new Error('jpg: failed to decode');\n  if (1 === ptr) throw new Error('jpg: failed to scale decoder');\n\n  const framebuffer = {\n    width: wasm.decode_width(ptr),\n    height: wasm.decode_height(ptr),\n    format: wasm.decode_format(ptr),\n    buffer: mem.u8(wasm.decode_buffer(ptr), mem.length()).slice(),\n  }\n\n  return (wasm.decode_free(ptr), framebuffer);\n}\n\nmodule.exports = {\n  encode,\n  decode,\n\n  async init() {\n    if (wasm) return;\n    const streaming = 'compileStreaming' in WebAssembly;\n    const module = await WebAssembly[!streaming ? 'compile' : 'compileStreaming'](await fetch(`https://unpkg.com/imagescript@${version}/utils/wasm/jpeg.wasm`).then(x => streaming ? x : x.arrayBuffer()));\n    const instance = await WebAssembly.instantiate(module);\n\n    wasm = instance.exports;\n  }\n}\n","const {version} = require('../../package.json');\n\nlet wasm;\n\nclass mem {\n  static length() { return wasm.wlen(); }\n  static alloc(size) { return wasm.walloc(size); }\n  static free(ptr, size) { return wasm.wfree(ptr, size); }\n  static u8(ptr, size) { return new Uint8Array(wasm.memory.buffer, ptr, size); }\n  static u32(ptr, size) { return new Uint32Array(wasm.memory.buffer, ptr, size); }\n\n  static copy_and_free(ptr, size) {\n    let slice = mem.u8(ptr, size).slice();\n    return (wasm.wfree(ptr, size), slice);\n  }\n}\n\nfunction rasterize(buffer, fit, scale) {\n    const bptr = mem.alloc(buffer.length);\n    mem.u8(bptr, buffer.length).set(buffer);\n    const ptr = wasm.rasterize(bptr, buffer.length, fit, scale);\n  \n    if (0 === ptr) throw new Error('svg: failed to parse');\n    if (1 === ptr) throw new Error('svg: failed to rasterize');\n  \n    const framebuffer = {\n      width: wasm.rasterize_width(ptr),\n      height: wasm.rasterize_height(ptr),\n      buffer: mem.u8(wasm.rasterize_buffer(ptr), mem.length()).slice(),\n    }\n  \n    return (wasm.rasterize_free(ptr), framebuffer);\n}\n\nmodule.exports = {\n    rasterize,\n\n    async init() {\n        if (wasm) return;\n        const streaming = 'compileStreaming' in WebAssembly;\n        const module = await WebAssembly[!streaming ? 'compile' : 'compileStreaming'](await fetch(`https://unpkg.com/imagescript@${version}/utils/wasm/svg.wasm`).then(x => streaming ? x : x.arrayBuffer()));\n        const instance = await WebAssembly.instantiate(module);\n\n        wasm = instance.exports;\n    }\n}\n","const {version} = require('../../package.json');\n\nlet wasm;\n\nclass mem {\n  static length() { return wasm.wlen(); }\n  static alloc(size) { return wasm.walloc(size); }\n  static free(ptr, size) { return wasm.wfree(ptr, size); }\n  static u8(ptr, size) { return new Uint8Array(wasm.memory.buffer, ptr, size); }\n  static u32(ptr, size) { return new Uint32Array(wasm.memory.buffer, ptr, size); }\n\n  static copy_and_free(ptr, size) {\n    let slice = mem.u8(ptr, size).slice();\n    return (wasm.wfree(ptr, size), slice);\n  }\n}\n\nfunction decode(buffer) {\n\tconst bptr = mem.alloc(buffer.length);\n\tmem.u8(bptr, buffer.length).set(buffer);\n\tconst ptr = wasm.decode(bptr, buffer.length);\n\tif (0 === ptr) throw new Error('tiff: failed to decode');\n\n\tconst framebuffer = {\n\t\twidth: wasm.decode_width(ptr),\n\t\theight: wasm.decode_height(ptr),\n\t\tbuffer: mem.u8(wasm.decode_buffer(ptr), mem.length()).slice(),\n\t}\n\n\treturn (wasm.decode_free(ptr), framebuffer);\n}\n\nmodule.exports = {\n\tdecode,\n\n\tasync init() {\n\t\tif (wasm) return;\n\t\tconst streaming = 'compileStreaming' in WebAssembly;\n\t\tconst module = await WebAssembly[!streaming ? 'compile' : 'compileStreaming'](await fetch(`https://unpkg.com/imagescript@${version}/utils/wasm/tiff.wasm`).then(x => streaming ? x : x.arrayBuffer()));\n\t\tconst instance = await WebAssembly.instantiate(module);\n\n\t\twasm = instance.exports;\n\t}\n}\n","const {version} = require('../../package.json');\n\nlet wasm;\n\nclass mem {\n  static length() { return wasm.wlen(); }\n  static alloc(size) { return wasm.walloc(size); }\n  static free(ptr, size) { return wasm.wfree(ptr, size); }\n  static u8(ptr, size) { return new Uint8Array(wasm.memory.buffer, ptr, size); }\n  static u32(ptr, size) { return new Uint32Array(wasm.memory.buffer, ptr, size); }\n\n  static copy_and_free(ptr, size) {\n    let slice = mem.u8(ptr, size).slice();\n    return (wasm.wfree(ptr, size), slice);\n  }\n}\n\nfunction compress(buffer, level = 3) {\n  const ptr = mem.alloc(buffer.length);\n  mem.u8(ptr, buffer.length).set(buffer);\n  return mem.copy_and_free(wasm.compress(ptr, buffer.length, level), mem.length());\n}\n\nfunction decompress(buffer, limit = 0) {\n  const ptr = mem.alloc(buffer.length);\n  mem.u8(ptr, buffer.length).set(buffer);\n  const x = wasm.decompress(ptr, buffer.length, limit);\n  if (0 === x) throw new Error('zlib: failed to decompress');\n\n  return mem.copy_and_free(x, mem.length());\n}\n\nmodule.exports = {\n  compress,\n  decompress,\n\n  async init() {\n    if (wasm) return;\n    const streaming = 'compileStreaming' in WebAssembly;\n    const module = await WebAssembly[!streaming ? 'compile' : 'compileStreaming'](await fetch(`https://unpkg.com/imagescript@${version}/utils/wasm/zlib.wasm`).then(x => streaming ? x : x.arrayBuffer()));\n    const instance = await WebAssembly.instantiate(module);\n\n    wasm = instance.exports;\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(655);\n"],"sourceRoot":""}